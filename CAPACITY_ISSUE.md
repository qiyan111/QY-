# 🔴 容量不足导致提前退出问题

## 问题现象

```
最大轮次: 301882 (理论充足)
实际运行: 11169 轮 (提前退出 ❌)

Mesos DRF: 67.0% 成功率
Tetris:    36.3% 成功率
NextGen:   57.6% 成功率
```

## 🔍 根本原因

### 容量与需求严重不匹配

```
集群容量: 10 节点 × 11 cores = 110 cores
任务总需求: 100000 × 0.062 = 6222 cores

容量/需求比: 110 / 6222 = 1.8% ❌

结论: 即使任务分散到达，高峰时段仍严重资源不足
```

### 循环提前退出机制

**代码循环条件**：
```python
while events or running_tasks:
    # 调度逻辑
```

**退出原因**：
1. 大量任务因资源不足重试 3 次后**永久失败**
2. 这些失败任务被移出事件队列（不再重试）
3. 事件队列逐渐清空
4. 当 `events` 为空且 `running_tasks` 为 0 时，循环退出
5. 提前退出，**即使模拟时间还没到最后**

### 验证数据

```
重试统计:
  重试任务数: 66263
  总重试次数: 169509
  平均重试: 2.6 次/任务 ← 接近最大限制 3 次
  永久失败: 42422 个任务 ← 这些任务被移出队列

循环提前退出:
  理论轮次: 201255
  实际轮次: 11169 (5.5%) ← 运行到 5.5% 就停了
```

## 🎯 解决方案

### 方案 1：大幅增加节点数（推荐）

```bash
export BATCH_STEP_SECONDS=3

# 增加到 60 个节点（容量 660 cores）
python tools/run_complete_comparison.py ./data 100000 60
```

**原理**：
- 60 节点 × 11 cores = **660 cores**
- 容量/需求比: 660 / 6222 = **10.6%**
- 虽然还不能同时运行所有任务，但配合任务时间分散，应该能达到 85-95% 成功率

**预期结果**：
- 成功率：85-95%
- 利用率：45-60%
- 算法差异明显

---

### 方案 2：使用更少的任务

```bash
export BATCH_STEP_SECONDS=3

# 使用 10000 个任务 + 10 个节点
python tools/run_complete_comparison.py ./data 10000 10
```

**原理**：
- 任务需求：10000 × 0.062 = **622 cores**
- 集群容量：110 cores
- 容量/需求比: 110 / 622 = **17.7%**
- 配合时间分散，足够调度大部分任务

**预期结果**：
- 成功率：95-100%
- 利用率：50-65%
- 运行时间短，便于调试

---

### 方案 3：增加重试次数 + 重试延迟

如果想"强行"提高成功率，可以让任务等待更久：

```bash
export BATCH_STEP_SECONDS=3
export MAX_TASK_RETRIES=10        # 增加到 10 次重试
export TASK_RETRY_DELAY=30        # 重试延迟 30 秒（需要代码支持）

python tools/run_complete_comparison.py ./data 100000 10
```

**问题**：
- 运行时间会非常长
- 仍然无法解决根本的容量不足问题
- **不推荐**

---

### 方案 4：使用时间窗口过滤（高级）

只模拟 trace 中某个高峰时段：

```bash
# 过滤出 1 小时内到达的任务
python tools/filter_concentrated_tasks.py ./data 3600 > filtered_tasks.csv

# 使用过滤后的数据
python tools/run_complete_comparison.py filtered_tasks.csv 0 20
```

**原理**：
- 只模拟短时间窗口（如 1 小时）
- 任务更集中，避免时间分散问题
- 能更清晰地看出算法差异

---

## 📊 对比矩阵

| 方案 | 节点数 | 任务数 | 容量比 | 预期成功率 | 预期利用率 | 运行时间 | 推荐度 |
|------|--------|--------|--------|------------|------------|---------|--------|
| **方案1：增加节点** | 60 | 100000 | 10.6% | 85-95% | 45-60% | 10-15分钟 | ⭐⭐⭐⭐⭐ |
| **方案2：减少任务** | 10 | 10000 | 17.7% | 95-100% | 50-65% | 2-3分钟 | ⭐⭐⭐⭐ |
| **方案3：增加重试** | 10 | 100000 | 1.8% | 60-70% | 20-30% | >30分钟 | ⭐ |
| **方案4：时间窗口** | 20 | ~50000 | 变化 | 90-100% | 60-75% | 5-8分钟 | ⭐⭐⭐⭐ |

---

## 💡 为什么会这样？

### 真实 Trace 的特点

Alibaba 2018 Trace：
- 任务到达分散在**数天**
- 某些时段高峰，某些时段低谷
- 高峰时段会超过集群容量
- 低谷时段集群空闲

### 事件驱动模拟的真实性

- ✅ **优点**：反映真实时间维度，包括空闲时间
- ⚠️ **缺点**：如果容量配置不当，会暴露资源不足问题

### 与静态模拟的差异

**静态模拟**（如之前的 NextGen）：
- 忽略时间，只看"能调度多少任务"
- 不关心容量是否充足
- 可能高估成功率

**事件驱动模拟**（现在所有算法）：
- 考虑时间和容量约束
- 容量不足会导致任务失败
- 更真实，但需要合理配置

---

## 🎯 推荐配置

### 对于算法性能对比（推荐）

```bash
export BATCH_STEP_SECONDS=3
python tools/run_complete_comparison.py ./data 10000 10
```

**预期结果**：
```
算法          成功率   利用率
────────────────────────────
Mesos DRF    100.0%   55-60%
Tetris        98.0%   45-50%
NextGen      100.0%   60-65%
```

### 对于大规模压力测试

```bash
export BATCH_STEP_SECONDS=3
python tools/run_complete_comparison.py ./data 100000 60
```

**预期结果**：
```
算法          成功率   利用率
────────────────────────────
Mesos DRF     95.0%   50-55%
Tetris        88.0%   40-45%
NextGen       98.0%   55-60%
```

---

## 🔍 如何验证问题已解决？

运行后检查：

### 1. 成功率应该很高
```
算法          成功率
────────────────────
Mesos DRF    >95%   ✅
Tetris       >90%   ✅
NextGen      >98%   ✅
```

### 2. 不应该看到大量重试
```
重试统计: <5000 个任务重试  ✅
(而不是 66263)
```

### 3. 轮次应该接近理论值
```
理论轮次: 201255
实际轮次: ~180000  ✅
(而不是 11169)
```

### 4. 峰值利用率不应该 100%
```
峰值利用率: 70-85%  ✅
(而不是 100%)
```

如果峰值是 100%，说明容量还是不够。

---

## 📚 相关概念

### 容量规划 (Capacity Planning)

在真实系统中，需要根据**工作负载特征**配置合适的集群规模：

```
集群容量 = 峰值并发需求 × (1 + 安全余量)
```

对于这个 trace：
- 峰值并发需求：需要分析 trace 数据
- 安全余量：通常 20-30%
- 如果容量 < 峰值需求 → 任务失败
- 如果容量 >> 峰值需求 → 利用率低

### 过载保护 (Overload Protection)

当资源不足时的策略：
- **重试**：让任务等待（本系统当前策略）
- **降级**：降低任务优先级
- **拒绝**：直接拒绝新任务
- **弹性伸缩**：动态增加节点（云环境）

---

## ✅ 修复状态

- ✅ 最大轮次限制已修复（301882）
- ⚠️ 容量配置需要调整（根据任务数）
- 📝 问题已明确，解决方案已提供

---

**下一步**：选择一个方案并重新运行！

推荐从**方案2**开始（10000 任务），验证算法对比逻辑正确后，再尝试方案1（大规模测试）。

---

**最后更新**: 2025-10-22  
**问题类型**: 容量规划，非代码 bug  
**影响**: 所有使用大量任务的实验
